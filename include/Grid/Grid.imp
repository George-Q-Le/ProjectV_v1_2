/*  Copyright 2017 George Le

*/
#include "Grid/Grid.h"

template<class TEntityType>
CGrid<TEntityType>::CGrid() : m_max_rows(DEFAULT_ROW_AMOUNT)
{
    // filling up the grid to have at least one square for all the rows
    int y = 0;
    // set up at least 2 grid squares for two opponents squaring off in close range
    // and in front of each other
    for(int x = 0; x < 2; ++x)
    {
        // creates a grid square at position (0,1) and then iterates the x value
        CGridSquare<TEntityType> grid_square(x, y, true);
        grid_square.RegisterSubscribers(*this);
        m_grid[x].push_back(grid_square);
    }
}

template<class TEntityType>
CGrid<TEntityType>::CGrid(int max_rows) : m_max_rows(max_rows)
{
    // filling up the grid to have at least one square for all the rows
    int y = 0;
    // set up at least 2 grid squares for two opponents squaring off in close range
    // and in front of each other
    for(int x = 0; x < 2; ++x)
    {
        // creates a grid square at position (0,1) and then iterates the x value
        CGridSquare<TEntityType> grid_square(x, y, true);
        grid_square.RegisterSubscribers(*this);
        m_grid[x].push_back(grid_square);
    }
}

template<class TEntityType>
double CGrid<TEntityType>::GetDistance(const CGridSquare<TEntityType>& first, const CGridSquare<TEntityType>& second)
{
    return sqrt(pow((static_cast<double>(second.get_location().m_x) - static_cast<double>(first.get_location().m_x)), 2.0) + 
                pow((static_cast<double>(second.get_location().m_y) - static_cast<double>(first.get_location().m_y)), 2.0));
}

template<class TEntityType>
bool CGrid<TEntityType>::Move(std::shared_ptr<TEntityType> calling_entity, int direction)
{
    bool f_success = false;
    
    return f_success;
}

template<class TEntityType>
void CGrid<TEntityType>::NotifyOnEvent()
{
    
}